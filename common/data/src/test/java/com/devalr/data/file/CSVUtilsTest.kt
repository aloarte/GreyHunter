package com.devalr.data.file

import junit.framework.TestCase.assertEquals
import org.junit.Test

class CsvUtilsTest {

    @Test
    fun `GIVEN null String WHEN escapeCsv is called THEN returns empty String`() {
        // GIVEN
        val value: String? = null

        // WHEN
        val result = value.escapeCsv()

        // THEN
        assertEquals("", result)
    }

    @Test
    fun `GIVEN normal String without special chars WHEN escapeCsv is called THEN returns same String`() {
        // GIVEN
        val value = "Space marine"

        // WHEN
        val result = value.escapeCsv()

        // THEN
        assertEquals("Space marine", result)
    }

    @Test
    fun `GIVEN String with comma WHEN escapeCsv is called THEN wraps value in quotes`() {
        // GIVEN
        val value = "Space, marine"

        // WHEN
        val result = value.escapeCsv()

        // THEN
        assertEquals("\"Space, marine\"", result)
    }

    @Test
    fun `GIVEN String with newline WHEN escapeCsv is called THEN wraps value in quotes`() {
        // GIVEN
        val value = "Line1\nLine2"

        // WHEN
        val result = value.escapeCsv()

        // THEN
        assertEquals("\"Line1\nLine2\"", result)
    }

    @Test
    fun `GIVEN String with quotes WHEN escapeCsv is called THEN escapes quotes correctly`() {
        // GIVEN
        val value = "The \"Emperor\""

        // WHEN
        val result = value.escapeCsv()

        // THEN
        assertEquals("The \"\"Emperor\"\"", result)
    }

    @Test
    fun `GIVEN String with comma and quotes WHEN escapeCsv is called THEN escapes and wraps correctly`() {
        // GIVEN
        val value = "The \"Emperor\", of Mankind"

        // WHEN
        val result = value.escapeCsv()

        // THEN
        assertEquals("\"The \"\"Emperor\"\", of Mankind\"", result)
    }

    @Test
    fun `GIVEN simple CSV line WHEN parseCsvLine is called THEN returns correct values`() {
        // GIVEN
        val line = "1,Space marine,0.5"

        // WHEN
        val result = parseCsvLine(line)

        // THEN
        assertEquals(listOf("1", "Space marine", "0.5"), result)
    }

    @Test
    fun `GIVEN CSV line with quoted comma WHEN parseCsvLine is called THEN keeps comma inside value`() {
        // GIVEN
        val line = "1,\"Space, marine\",0.5"

        // WHEN
        val result = parseCsvLine(line)

        // THEN
        assertEquals(listOf("1", "Space, marine", "0.5"), result)
    }

    @Test
    fun `GIVEN CSV line with multiple quoted fields WHEN parseCsvLine is called THEN parses correctly`() {
        // GIVEN
        val line = "1,\"Space, marine\",\"Description, here\",0.5"

        // WHEN
        val result = parseCsvLine(line)

        // THEN
        assertEquals(
            listOf("1", "Space, marine", "Description, here", "0.5"),
            result
        )
    }

    @Test
    fun `GIVEN CSV line with empty field WHEN parseCsvLine is called THEN returns empty value`() {
        // GIVEN
        val line = "1,,0.5"

        // WHEN
        val result = parseCsvLine(line)

        // THEN
        assertEquals(listOf("1", "", "0.5"), result)
    }

    @Test
    fun `GIVEN quoted field with escaped quotes WHEN parseCsvLine is called THEN returns unescaped quotes`() {
        // GIVEN
        val line = "1,\"The \"\"Emperor\"\"\",0.5"

        // WHEN
        val result = parseCsvLine(line)

        // THEN
        assertEquals(
            listOf("1", "The \"Emperor\"", "0.5"),
            result
        )
    }

    @Test
    fun `GIVEN field with comma and escaped quotes WHEN parseCsvLine is called THEN parses correctly`() {
        // GIVEN
        val line = "1,\"The \"\"Emperor\"\", of Mankind\",0.5"

        // WHEN
        val result = parseCsvLine(line)

        // THEN
        assertEquals(
            listOf("1", "The \"Emperor\", of Mankind", "0.5"),
            result
        )
    }

    @Test
    fun `GIVEN fully escaped CSV generated by escapeCsv WHEN parsed THEN round trip is correct`() {
        // GIVEN
        val original = "The \"Emperor\", of Mankind"
        val escaped = original.escapeCsv()
        val line = "1,$escaped,0.5"

        // WHEN
        val result = parseCsvLine(line)

        // THEN
        assertEquals(original, result[1])
    }

    @Test
    fun `GIVEN multiple complex fields WHEN parseCsvLine is called THEN all values are parsed correctly`() {
        // GIVEN
        val line = "10,\"Space, marine\",\"Line1\nLine2\",\"The \"\"Emperor\"\"\""

        // WHEN
        val result = parseCsvLine(line)

        // THEN
        assertEquals(
            listOf(
                "10",
                "Space, marine",
                "Line1\nLine2",
                "The \"Emperor\""
            ),
            result
        )
    }
}